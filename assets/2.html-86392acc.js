const e=JSON.parse('{"key":"v-bfa104bc","path":"/my-world/personal-project/Java%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%BA%93/2.html","title":"DM中的缓存类与数据页缓存","lang":"zh-CN","frontmatter":{"title":"DM中的缓存类与数据页缓存","order":3,"date":"2022-12-06T00:00:00.000Z","category":["个人项目"],"tag":["Java","数据库"],"description":"DM确实是一个比较困难的编写地方，所以我们将分为好几个章节来讲解 引用计数法 为啥使用引用计数而不使用LRU，如果使用LRU缓存，那么只需要设计一个get(key) 接口即可，释放缓存可以在缓存满了之后自动完成，但是在这样一个场景下，某个时刻缓存满了，缓存驱逐了一个资源，但是这个缓存的资源可能是另一个线程正在被需要的，那么这个缓存是否应该回源(回源的意思就是写回磁盘)，如果回源那么又需要那产生抖动，如果不回源，那么可能会造成脏页，MySQL可能对此做了许多优化，而在本项目中就使用比较简单的引用计数法 缓存的抽象类 这个类是一个比较重要的缓存类，比如获取数据都是调用这个缓存类中的方法，当缓存中如果没有需要获取的资源的时候就需要从文件中读取进缓存(getForCache 方法)，同时也有着将资源回源(将缓存中的数据写回数据中)的方法(releaseForCache)，因为这是一个抽取出来的缓存公用的类，对于页面、数据的缓存其实从文件中读取出来的格式存在一些差异，所以getForCache方法与releaseForCache方法由具体继承这个类的子类去实现","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-world/personal-project/Java%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%BA%93/2.html"}],["meta",{"property":"og:title","content":"DM中的缓存类与数据页缓存"}],["meta",{"property":"og:description","content":"DM确实是一个比较困难的编写地方，所以我们将分为好几个章节来讲解 引用计数法 为啥使用引用计数而不使用LRU，如果使用LRU缓存，那么只需要设计一个get(key) 接口即可，释放缓存可以在缓存满了之后自动完成，但是在这样一个场景下，某个时刻缓存满了，缓存驱逐了一个资源，但是这个缓存的资源可能是另一个线程正在被需要的，那么这个缓存是否应该回源(回源的意思就是写回磁盘)，如果回源那么又需要那产生抖动，如果不回源，那么可能会造成脏页，MySQL可能对此做了许多优化，而在本项目中就使用比较简单的引用计数法 缓存的抽象类 这个类是一个比较重要的缓存类，比如获取数据都是调用这个缓存类中的方法，当缓存中如果没有需要获取的资源的时候就需要从文件中读取进缓存(getForCache 方法)，同时也有着将资源回源(将缓存中的数据写回数据中)的方法(releaseForCache)，因为这是一个抽取出来的缓存公用的类，对于页面、数据的缓存其实从文件中读取出来的格式存在一些差异，所以getForCache方法与releaseForCache方法由具体继承这个类的子类去实现"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-30T15:44:42.000Z"}],["meta",{"property":"article:author","content":"CodeVmore"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2022-12-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-30T15:44:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"DM中的缓存类与数据页缓存\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-12-06T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-30T15:44:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeVmore\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"引用计数法","slug":"引用计数法","link":"#引用计数法","children":[]},{"level":2,"title":"缓存的抽象类","slug":"缓存的抽象类","link":"#缓存的抽象类","children":[{"level":3,"title":"缓存记录","slug":"缓存记录","link":"#缓存记录","children":[]},{"level":3,"title":"获取数据","slug":"获取数据","link":"#获取数据","children":[]},{"level":3,"title":"释放缓存","slug":"释放缓存","link":"#释放缓存","children":[]},{"level":3,"title":"获取数据与缓存回源","slug":"获取数据与缓存回源","link":"#获取数据与缓存回源","children":[]}]},{"level":2,"title":"数据页的缓存","slug":"数据页的缓存","link":"#数据页的缓存","children":[{"level":3,"title":"PageOne","slug":"pageone","link":"#pageone","children":[]},{"level":3,"title":"初始化、拷贝、校验方法","slug":"初始化、拷贝、校验方法","link":"#初始化、拷贝、校验方法","children":[]},{"level":3,"title":"PageX","slug":"pagex","link":"#pagex","children":[]},{"level":3,"title":"设置与获取偏移量","slug":"设置与获取偏移量","link":"#设置与获取偏移量","children":[]},{"level":3,"title":"页面缓存","slug":"页面缓存","link":"#页面缓存","children":[]},{"level":3,"title":"提供功能","slug":"提供功能","link":"#提供功能","children":[]}]},{"level":2,"title":"页面索引","slug":"页面索引","link":"#页面索引","children":[{"level":3,"title":"添加页面进索引","slug":"添加页面进索引","link":"#添加页面进索引","children":[]},{"level":3,"title":"选择一个页面","slug":"选择一个页面","link":"#选择一个页面","children":[]},{"level":3,"title":"填充PageIndex","slug":"填充pageindex","link":"#填充pageindex","children":[]}]}],"git":{"createdTime":1682869482000,"updatedTime":1682869482000,"contributors":[{"name":"李博","email":"libo04@rd.netease.com","commits":1}]},"readingTime":{"minutes":7.77,"words":2332},"filePathRelative":"my-world/personal-project/Java实现的简易数据库/2.md","localizedDate":"2022年12月6日","excerpt":"<p>DM确实是一个比较困难的编写地方，所以我们将分为好几个章节来讲解</p>\\n<h2> 引用计数法</h2>\\n<p>为啥使用引用计数而不使用LRU，如果使用LRU缓存，那么只需要设计一个get(key) 接口即可，释放缓存可以在缓存满了之后自动完成，但是在这样一个场景下，某个时刻缓存满了，缓存驱逐了一个资源，但是这个缓存的资源可能是另一个线程正在被需要的，那么这个缓存是否应该回源(回源的意思就是写回磁盘)，如果回源那么又需要那产生抖动，如果不回源，那么可能会造成脏页，MySQL可能对此做了许多优化，而在本项目中就使用比较简单的引用计数法</p>\\n<h2> 缓存的抽象类</h2>\\n<p>这个类是一个比较重要的缓存类，比如获取数据都是调用这个缓存类中的方法，当缓存中如果没有需要获取的资源的时候就需要从文件中读取进缓存(getForCache 方法)，同时也有着将资源回源(将缓存中的数据写回数据中)的方法(releaseForCache)，因为这是一个抽取出来的缓存公用的类，对于页面、数据的缓存其实从文件中读取出来的格式存在一些差异，所以getForCache方法与releaseForCache方法由具体继承这个类的子类去实现</p>","autoDesc":true}');export{e as data};
